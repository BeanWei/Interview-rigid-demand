# python语法以及其他基础部分

## 0).可变与不可变类型

可变类型：列表，字典

不可变类型：数字，字符串，元组

对不可变类型的变量重新赋值，实际上是重新创建一个不可变类型的对象，并将原来的变量重新指向新创建的对象（如果没有其他变量引用原有对象的话（即引用计数为0），原有对象就会被回收）

Note: 使用 python 内置函数 ` id ` id() 可以查看变量的内存地址进行验证，使用 `hex(id(i))` 可以查看16进制的内存地址。



1).浅拷贝与深拷贝的实现方式、区别；deepcopy如果你来设计，如何实现

基本概念：
python中的对象之间赋值时是按引用传递的，如果需要拷贝对象则需要使用标准库中的copy模块

1. copy.copy 浅拷贝 只拷贝父对象，不会拷贝对象的内部的子对象
2. copy.deepcopy 深拷贝 拷贝对象及其子对象
   
```
>>> import copy
>>> a = [1, 2, 3, ['a', 'b']]
>>> b = a
>>> c = copy.copy(a)
>>> d = copy.deepcopy(a)
>>> a.append(5)
>>> a[3].append('c')
>>> print(a)
[1, 2, 3, ['a', 'b', 'c'], 5]
>>> print(b)
[1, 2, 3, ['a', 'b', 'c'], 5]
>>> print(c)
[1, 2, 3, ['a', 'b', 'c']]
>>> print(d)
[1, 2, 3, ['a', 'b']]
>>> id(a)
31922456
>>> id(b)
31922456
>>> id(c)
31922296
>>> id(d)
31922336
```

***浅复制只复制一层对象的属性，而深复制则递归复制了所有层级***

Note: 深拷贝并非完完全全递归查找所有对象，因为一旦对象引用了自身，完全递归可能会导致无限循环。一个对象被拷贝了，python 会对该对象做个标记，如果还有其他需要拷贝的对象引用着该对象，它们的拷贝其实指向的是同一份拷贝



## 2).__new__() 与 __init__()的区别

异同点:
1. 参数
* __new__的第一个占位参数是class对象
* __init__的第一个占位参数是class的实例对象
* 其他的参数应一致
2. 作用
* __new__ 用来创建实例，在返回的实例上执行__init__，如果不返回实例那么__init__将不会执行
* __init__ 用来初始化实例，设置属性什么的

可以这么描述__new__()和__ini__()的区别，在新式类中__new__()才是真正的实例化方法，为类提供外壳制造出实例框架，然后调用该框架内的构造方法__init__()使其丰满。

**如果以建房子做比喻，__new__()方法负责开发地皮，打下地基，并将原料存放在工地。而__init__()方法负责从工地取材料建造出地皮开发招标书中规定的大楼，__init__()负责大楼的细节设计，建造，装修使其可交付给客户。**

Note: 
* 在类中，如果该类具有__new__方法，会先调用__new__方法
* __new__方法会返回所构造的对象，__init__则不会。__init__无返回值。
* 如果__new__返回一个对象的实例，会隐式调用__init__
* 如果__new__不返回一个对象的实例，__init__不会被调用
  
### 注意：
Python 2.x中默认都是经典类，只有显式继承了object才是新式类

而Python 3.x中默认都是新式类（也即object类默认是所有类的祖先），不必显式的继承object（可以按照经典类的定义方式写一个经典类并分别在python2.x和3.x版本中使用dir函数检验下。



## 3).你知道几种设计模式

>设计模式的定义:为了解决面向对象系统中重要和重复的设计封装在一起的一种代码实现框架,可以使得代码更加易于扩展和调用

[python设计模式](https://github.com/BeanWei/Interview-rigid-demand/blob/master/You%20must%20know/python%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.md)




## 4).编码和解码你了解过么

字符串在Python内部的表示是unicode编码，因此，在做编码转换时，通常需要以unicode作为中间编码，即先将其他编码的字符串解码（decode）成unicode，再从unicode编码（encode）成另一种编码。

encode与decode
decode的作用是将其他编码的字符串转换成unicode编码，如str1.decode(‘utf-8’)，表示将utf-8编码的字符串转换成unicode编码。

encode的作用是将unicode编码转换成其他编码的字符串，如str2.encode(‘utf-8’)，表示将unicode编码的字符串转换成utf-8编码。



## 5).列表推导list comprehension和生成器的优劣

* 列表推导式是将所有的值一次性加载到内存中
* 生成器是将列表推导式的[]改成(),不会将所有的值一次性加载到内存中,延迟计算,一次返回一个结果,它不会一次生成所有的结果,这对大数据量处理,非常有用
* 列表推导式可以遍历任意次, 生成器只能遍历一次
  

## 6).什么是装饰器；如果想在函数之后进行装饰，应该怎么做

1. [python装饰器](https://github.com/BeanWei/Interview-rigid-demand/blob/master/You%20must%20know/python%E8%A3%85%E9%A5%B0%E5%99%A8.md)

2. 将装饰代码部分放置 func() 后面即可实现



## 7).手写个使用装饰器实现的单例模式

[python单例模式](https://github.com/BeanWei/Interview-rigid-demand/blob/master/You%20must%20know/python%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.md)

代码：
```
def singleton(cls):
    _instance = {}
    def _singleton(*args, **kwargs):
        if cls not in _instance:
            _instance[cls] = cls(*args, **kwargs)
        return _instance[cls]
    return _singleton

@singleton
class Foo:
    def __init__(self):
        pass

class Bar:
    def __init__(self):
        pass

a, b, c, d = Foo(), Foo(), Bar(), Bar()

print(a == b)

print(c == d)

output:
True
False
```



## 8).使用装饰器的单例和使用其他方法的单例，在后续使用中，有何区别
实现单例模式的几种方法：
1. 使用模块         
2. 使用装饰器          =>  灵活易复用
3. 使用类                
4. 基于__new__方法实现(推荐)
5. 基于metaclass方式实现

## 9).手写：正则邮箱地址

[python正则详解](https://github.com/BeanWei/Interview-rigid-demand/blob/master/You%20must%20know/python3%E4%B9%8B%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3.md)

假定email地址的必要形式为：
xxxxxx@xxxxxxxx.xxxxxx
其他一概不作检查，对应的RE应为：` [^@]+@[^@]+\.[^@]+ `

验证脚本：
```
import re
p = re.compile(r"[^@]+@[^@]+\.[^@]+")
#p = re.compile(r'([^@]+)@([^@]+)\.([^@]+)')  如果改成这种形式，后面可以输出帐号
emails = ['a@uuuuuu.xyzuv', '@', '@.org', '@xxx.com',
          'xsd@.cn', 'rs@233.', 'c', 'cde@', 'xy@163.com']
for each in emails:
    if not p.match(each):
        print(each, " NOT valid")
    else:
        print(each, ' is valid')
        #print(p.match(each).groups()) 
```
运行结果：
```
a@uuuuuu.xyzuv  is valid
#('a', 'uuuuuu', 'xyzuv')
@  NOT valid
@.org  NOT valid
@xxx.com  NOT valid
xsd@.cn  NOT valid
rs@233.  NOT valid
c  NOT valid
cde@  NOT valid
xy@163.com  is valid
#('xy', '163', 'com')
```



## 10).介绍下垃圾回收：引用计数/分代回收/孤立引用环

垃圾回收：

1. 引用计数：Python解释器对正在使用的对象保持计数。当对象不再被引用指向的时候(引用计数为0)，垃圾收集器可以释放该对象，获取分配的内存。
    * 优点：简单实时,一旦没有引用，内存就直接释放了。不用像其他机制等到特定时机。实时性还带来一个好处：处理回收内存的时间分摊到了平时。
    * 缺点： 维护引用计数消耗资源,会造成循环引用导致无法回收,造成内存泄露

2. 分代回收：分代技术是一种典型的以空间换时间的技术，对象存在时间越长，越可能不是垃圾，应该越少去收集。可以减少标记-清除机制所带来的额外操作。分代就是将回收对象分成数个代，每个代就是一个链表（集合），代进行标记-清除的时间与代内对象。

3. 孤立引用环：引用环的存在会给上面的垃圾回收机制带来很大的困难。这些引用环可能构成无法使用，但引用计数不为0的一些对象。
    ![引用环](http://s5.sinaimg.cn/mw690/005vaeekzy76DRwdMck74&690)
    孤立的引用环 => 
    ![孤立的引用环](http://s14.sinaimg.cn/mw690/005vaeekzy76DRxP9vL6d&690)
    为了回收这样的引用环，Python复制每个对象的引用计数，可以记为gc_ref。假设，每个对象i，该计数为gc_ref_i。Python会遍历所有的对象i。对于每个对象i引用的对象j，将相应的gc_ref_j减1。在结束遍历后，gc_ref不为0的对象，和这些对象引用的对象，以及继续更下游引用的对象，需要被保留。而其它的对象则被垃圾回收。



## 11).多进程与多线程的区别,CPU密集型适合用什么

线程与进程是操作系统里面的术语，简单来讲，每一个应用程序都有一个自己的进程。
操作系统会为这些进程分配一些执行资源，例如内存空间等。
在进程中，又可以创建一些线程，他们共享这些内存空间，并由操作系统调用，
以便并行计算。

### 进程与线程区别
1. 同一个进程中的线程共享同一内存空间，但是进程之间是独立的。
2. 同一个进程中的所有线程的数据是共享的（进程通讯），进程之间的数据是独立的。
3. 对主线程的修改可能会影响其他线程的行为，但是父进程的修改（除了删除以外）不会影响其他子进程。
4. 线程是一个上下文的执行指令，而进程则是与运算相关的一簇资源。
5. 同一个进程的线程之间可以直接通信，但是进程之间的交流需要借助中间代理来实现。
6. 创建新的线程很容易，但是创建新的进程需要对父进程做一次复制。
7. 一个线程可以操作同一进程的其他线程，但是进程只能操作其子进程。
8. 线程启动速度快，进程启动速度慢（但是两者运行速度没有可比性）。

### 计算密集型(CPU密集型)
1. 特点：要进行大量的计算，消耗CPU资源。比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。

2. 计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。

3. 计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。

### IO密集型
1. 涉及到网络、磁盘IO的任务都是IO密集型任务。

2. 特点：CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。

3. 对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。

4. IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。



## 12).进程通信的方式有几种

进程之间有很多通信的方式，除了socket，还有pipe和queue。

**Note: 关于queue，有一个是线程安全的，有一个是线程不安全的。**
```
1.from Queue import Queue
这个是普通的队列模式，类似于普通列表，先进先出模式，get方法会阻塞请求，直到有数据get出来为止
2.from multiprocessing.Queue import Queue
这个是多进程并发的Queue队列，用于解决多进程间的通信问题。普通Queue实现不了。
例如来跑多进程对一批IP列表进行运算，运算后的结果都存到Queue队列里面，这个就必须使用multiprocessing提供的Queue来实现
```



## 13).介绍下协程，为何比线程还快

协程，又称微线程，纤，英文名Coroutine。***协程是一种用户态的轻量级线程。***

线程是系统级别的，它们是由操作系统调度；协程是程序级别的，由程序员根据需要自己调度。我们把一个线程中的一个个函数叫做子程序，那么子程序在执行过程中可以中断去执行别的子程序；别的子程序也可以中断回来继续执行之前的子程序，这就是协程。也就是说同一线程下的一段代码<1>执行着执行着就可以中断，然后跳去执行另一段代码，当再次回来执行代码块<1>的时候，接着从之前中断的地方开始执行。
**那么很容易想到Python的yield，显然yield是可以实现这种切换的。**

>协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈。因此：协程能保留上一次调用时的状态（即所有局部状态的一个特定组合），每次过程重入时，就相当于进入上一次调用的状态，换种说法：进入上一次离开时所处逻辑流的位置。

### 协程的优缺点
**协程的优点：**

　　（1）无需线程上下文切换的开销，协程避免了无意义的调度，由此可以提高性能（但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力）

　　（2）无需原子操作锁定及同步的开销

　　（3）方便切换控制流，简化编程模型

　　（4）高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。

***协程的缺点：***

　　（1）无法利用多核资源：协程的本质是个单线程,它不能同时将 单个CPU 的多个核用上,协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。

　　（2）进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序

### 协程相比线程效率更高速度更快
1. 协程极高的执行效率。因为子程序切换不是线程切换，而是由程序自身控制，因此，没有线程切换的开销，和多线程比，线程数量越多，协程的性能优势就越明显。
2. 协程不需要多线程的锁机制，因为只有一个线程，也不存在同时写变量冲突，在协程中控制共享资源不加锁，只需要判断状态就好了，所以执行效率比多线程高很多。



## 14).range和xrange的区别
```
#coding:utf-8

import time
from functools import wraps

def duration(f):
    @wraps(f)
    def wrapper():
        s_time = time.time()
        f()
        e_time = time.time()
        print(u'用时：%d s' % (e_time - s_time))
    return wrapper

@duration
def testrange():
    for num in range(1000000):
        print(num)


if __name__ == '__main__':
    testrange()
```
windows环境下运行上面这段代码：py3需要70s, py2需要135s.

range()返回一个递增或递减的数字列表,列表的元素值由三个参数决定
start表示列表开始的值,默认为“0”。
stop 表示列表结束的值,该参数不可缺少
参数step表示步长,默认值为“1”。
range()返回的是一个递增或递减的数字列表。

xrange 是一个类,返回的是一个xrange对象。使用xrange()进行遍历,每次遍历只返回一个值。range()返回的是一个列表,一次性计算并返回所有的值。因此,xrange()的执行效率要高于range()

python3中的range就是python2中的xrange。



# 算法排序部分

1).手写快排；堆排；几种常用排序的算法复杂度是多少；快排平均复杂度多少，最坏情况如何优化

快排：
```python
def quicksort(list):
    if len(list) < 2:
        return list
    else:
        midpivot = list[0]
        lessbeforemidpivot = [i for i in list[1:] if i <= midpivot]
        biggeraftermidpivot = [i for i in list[1:] if i > midpivot]
        finallylist = quicksort(lessbeforemidpivot) + [midpivot] + quicksort(biggeraftermidpivot)
        return finallylist
```

2).手写：已知一个长度n的无序列表，元素均是数字，要求把所有间隔为d的组合找出来，你写的解法算法复杂度多少

3).手写：一个列表A=[A1，A2，…,An]，要求把列表中所有的组合情况打印出来；

4).手写：用一行python写出1+2+3+…+10**8

5).手写python：用递归的方式判断字符串是否为回文

6).单向链表长度未知，如何判断其中是否有环

7).单向链表如何使用快速排序算法进行排序

8).手写：一个长度n的无序数字元素列表，如何求中位数，如何尽快的估算中位数，9).你的算法复杂度是多少；

10).如何遍历一个内部未知的文件夹（两种树的优先遍历方式）



# 网络基础部分

## 1).TCP/IP分别在模型的哪一层
TCP: 传输层; IP: 互连网络层.
>TCP/IP 的体系结构分为：网络接口层->网络层->运输层(TCP或UDP)->应用层(各种应用层协议如TELNET,FTP,SMTP等)
[网络7层协议，4层，5层？理清容易混淆的几个概念](https://blog.csdn.net/cc1949/article/details/79063439)


## 2).socket长连接是什么意思
***Socket长连接和短连接***:
长连接与短连接的概念：前者是整个通讯过程，客户端和服务端只用一个Socket对象，长期保持Socket的连接；后者是每次请求，都新建一个Socket,处理完一个请求就直接关闭掉Socket。所以，其实区分长短连接就是：整个客户和服务端的通讯过程是利用一个Socket还是多个Socket进行的。
>1、对应流关闭，Socket的对应输入（出）数据的通道也就关闭，此时无法达到长连接效果；
>2、关闭Socket，记得显式关闭流与socket,顺序是线管流再关socket.
>3、要实先长连接，一般需要发送结束标记符号来告诉客户端服务端的某段消息已经发送完毕，否则客户端会一直阻塞在read方法。
***短连接和长连接有不同的用途：对于某次服务只需要一次回话的客户，使用短连接显得简单；但是，如果该次服务需要很多交互式的操作通信，那还是长连接比较高性能，毕竟，Socket的打开和关闭都是很耗性能的。***


## 3).select和epoll你了解么，区别在哪
select和epoll属于I/O多路复用模型，用于持续监听多个socket，获取其IO事件

select（轮询）: 该模型轮询各socket，不管socket是否活跃，随着socket数的增加，性能逐渐下降。
epoll（触发）: epoll采用了中断注册回调的方式，socket IO就绪时发出中断，然后将socket加入就绪队列。由三个系统调用：epoll_create，epoll_ctl，epoll_wait。

区别：
1. 支持一个进程所能打开的最大连接数：select有FD_SETSIZE宏定义，其大小是32个整数的大小；epoll虽然连接数有上限，但是很大，1G内存的机器上可以打开10万左右的连接，2G内存的机器可以打开20万左右的连接
2. 消息传递方式： select内核需要将消息传递到用户空间，都需要内核拷贝动作；epoll通过内核和用户空间共享一块内存来实现的。

## 4).TCP UDP区别；三次握手四次挥手讲一下
>TCP/IP协议是一个协议簇。里面包括很多协议的。UDP只是其中的一个, TCP/IP协议集包括应用层,传输层，网络层，网络访问层

* TCP是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。TCP连接要经历三次握手,断开要经历四次挥手
* UDP是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。
  >我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。

***三次握手四次挥手***:
一个TCP连接必须要经过三次“对话”才能建立: 主机A向主机B发出连接请求数据包（SYN） -> 主机B向主机A发送同意连接（ACK）和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包(SYN) -> 主机A再发出一个数据包(SYN)确认主机B的要求同步, 三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。
 TCP断开连接要进行4次: 当主机A完成数据传输后,将控制位FIN置1,提出停止TCP连接的请求 -> 主机B收到FIN后对其作出响应,确认这一方向上的TCP连接将关闭,将ACK置1 -> 由B 端再提出反方向的关闭请求,将FIN置1 -> 主机A对主机B的请求进行确认,将ACK置1,双方向的关闭结束.

**TCP连接三次握手四次挥手大大提高了数据通信的可靠性,使发送数据端和接收端在数据正式传输前就有了交互,为数据正式传输打下了可靠的基础**

Note: 
* ACK:  TCP报头的控制位之一,对数据进行确认.确认由目的端发出,用它来告诉发送端这个序列号之前的数据段都收到了.比如,确认号为X,则表示前X-1个数据段都收到了,只有当ACK=1时,确认号才有效,当ACK=0时,确认号无效,这时会要求重传数据,保证数据的完整性.
* SYN:  同步序列号,TCP建立连接时将这个位置1
* FIN:  发送端完成发送任务位,当TCP完成数据传输需要断开时,提出断开连接的一方将这位置1


## 5).TIME_WAIT过多是因为什么
服务器主动关闭连接导致TIME_WAIT产生


## 6).http一次连接的全过程：你来说下从用户发起request——到用户接收到response
Web浏览器与Web服务器建立TCP连接 -> Web浏览器向Web服务器发送请求指令 -> Web浏览器发送请求头信息 -> Web服务器应答 -> Web服务器发送应答头消息 -> Web服务器向浏览器发送数据 -> Web服务器关闭TCP连接 


## 7).http连接方式。get和post的区别，你还了解其他的方式么
### http请求中的8种请求方法

1. options   返回服务器针对特定资源所支持的HTTP请求方法。也可以利用向Web服务器发送'*'的请求来测试服务器的功能性。

2. Get   向特定的资源发出请求。  

3. Post   向指定资源提交数据进行处理请求（提交表单、上传文件），又可能导致新的资源的建立或原有资源的修改

4. Put   向指定资源位置上上传其最新内容（从客户端向服务器传送的数据取代指定文档的内容）

5. Head  向服务器索要与GET请求相一致的响应，只不过响应体将不会被返回。这一方法可以在不必传输整个响应内容的情况下，就可以获取包含在响应消息头中的元信息。 

6. Delete   请求服务器删除request-URL所标示的资源*（请求服务器删除页面）

7. Trace   回显服务器收到的请求，用于测试和诊断

8. Connect   HTTP/1.1协议中能够将连接改为管道方式的代理服务器

***http服务器至少能实现get、head、post方法，其他都是可选的***


## 8).RESTful你知道么
### 1.关于rest
rest  :representational state transfer      表述性状态转移,是一种架构风格。
rest原则：
* <1> 网络上的所有事物都被抽象为资源
* <2> 每个资源都有一个唯一的资源标识符
* <3> 同一个资源具有多种表现形式(xml,json等)
* <4> 对资源的各种操作不会改变资源标识符
* <5> 所有的操作都是无状态的

### 2.关于restful
restful: 遵守了rest 原则 的web服务

理解：rest与restful相比，多了一个ful,就英语层面来说是一个形容词，restful翻译为中文为： “rest式的”

是rest式的什么呢？答案是 rest式的应用，rest风格的web服务也是rest式的应用，rest式的web服务是一种ROA(The Resource-Oriented Architecture)(面向资源的架构)。

### 3.两者的联系与区别
restful是由rest派生出来的。


## 9).状态码你知道多少，比如200/403/404/504等等
### 第一个数字有五种可能的取值：

- 1xx:   指示信息—表示请求已接收，继续处理。

- 2xx:   成功—表示请求已经被成功接收、理解、接受。

- 3xx:   重定向—要完成请求必须进行更进一步的操作。

- 4xx:   客户端错误—请求有语法错误或请求无法实现。

- 5xx: 服务器端错误—服务器未能实现合法的请求。

### 状态代码 状态描述    说明

200  OK    客户端请求成功

400  Bad Request   由于客户端请求有语法错误，不能被服务器所理解。

401  Unauthonzed   请求未经授权。这个状态代码必须和WWW-Authenticate报头域一起使用

403   Forbidden   服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因

404   Not Found   请求的资源不存在，例如，输入了错误的URL。

500  Internal Server Error 服务器发生不可预期的错误，导致无法完成客户端的请求。

503  Service Unavailable   服务器当前不能够处理客户端的请求，在一段时间之后，服务器可能会恢复正常



# 数据库部分

1).MySQL锁有几种；死锁是怎么产生的； 为何，以及如何分区、分表；

2).MySQL的char varchar text的区别:

了解join么,有几种有何区别，A LEFT JOIN B，查询的结果中，B没有的那部分是如何显示的(NULL)

3).索引类型有几种，BTree索引和hash索引的区别（我没答上来这俩在磁盘结构上的区别）

4).手写：如何对查询命令进行优化

5).NoSQL了解么，和关系数据库的区别,redis有几种常用存储类型



# Linux部分

讲一下你常用的Linux/git命令和作用；

查看当前进程是用什么命令，除了文件相关的操作外，你平时还有什么操作命令；




# Django项目部分

都是让简单的介绍下你在公司的项目，不管是不是后端相关的，主要是要体现出你干了什么

1).你在项目中遇到最难的部分是什么，你是怎么解决的； 你看过django的admin源码么

2).看过flask的源码么,你如何理解开源

3).MVC / MTV, 缓存怎么用, 中间件是干嘛的

4).CSRF是什么，django是如何避免的,XSS

5).如果你来设计login，简单的说一下思路

6).session和cookie的联系与区别,session为什么说是安全的

7).uWSGI和Nginx的作用；